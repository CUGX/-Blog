# JavaStep1__Java基础





## 一、Java基础

1. 文件名一般与public类名一样；

2. 一个文件中只能放一个public类

3. 写程序先写框架；再补全框架；

4. 大程序划分为几个小的部分，先测试一部分功能再集成实现完整功能。

   

### 1.1、Java变量；

> 变量用来标识一块内存；变量类型决定内存区域内能放什么类型的数据.

1. 变量声明后才能使用，声明时必须有类型声明（类型不同是可能出现精度问题），赋值时要匹配变量类型；
2. 一个作用域内，变量能重新赋值，不能重复定义（声明）；不同域内能重复定义并使用；
3. 变量有作用域，为离他最近的一对大括号内。
   - 单字母时首字母小写，多单词时，驼峰式命名；
   - 望文生义。



### 1.2、Java数据类型

1. int、float：4B；       long、double：8B ； 	char：2B ；  

2. byte、boolean：1B，boolean只有true和false

3. 修改输出进制:

   ```java
   Integer.toBinaryString();	//输出二进制；
   Integer.toHexString();  	//输出八进制
   ```

4. 要表示long型数字结尾加上l或L

   ```java
   long a = 10000000000l;long a = 10000000000L;
   ```

5. 要表示float类型变量，必须以f结尾；float不能作精确运算，有舍入误差.

   ```java
   float b = 10.2f;
   ```

6. 整数默认为int型；小数默认为double型；char为16位无符号数

7. 自动类型转换和强制类型转换

   ```java
   //自动类型转换，从小类到大类：byte short（char） int  long  float  double
   //强制类型转换，从大范围到小范围：
   long  l = 1024;
   	i = (int) l; 
   double pi = 3.14159265357;
   	float f = (float) pi;
   ```

   

### 1.3、Java运算符和表达式

1. 算数运算符：加+，减-，乘*，除/，取余%，自增++，自减--；

2. 关系运算符：>，<，>=，<=，==，!=  运算结果为true或者false；

3. 逻辑运算符：计算结果为true或者false

   ```java
   //	&&  当表达式1为假时，表达式2不计算
   表达式1 && 表达式2  
   //	||  当表达式1为真时，表达式2不计算
   表达式1 || 表达式2  
   ```

4. 条件运算符： 

   ```java
   //表达式1为true，返回表达式2为结果,
   //表达式1为false，返回表达式3为结果;
   boolean flag = 表达式1 ? 表达式2 : 表达式3  
   ```

5. 赋值运算符：=，+=，-=，*=，/=，%=

   ```java
   a += 20; 等价于 a = a+20;
   a /= 10; 等价于 a = a/10;
   b += 5.5; b = b+5.5;(错) 等价于 b = (int)(b+5.5);
   //面试题：short s = 1; 做加一运算，下面两种那种写法正确
   //===========》“+=”会做强制类型转换
   s = s+1;（错） s += 1;（正确）
   ```

6. 字符串连接运算符：+，字符串间的拼接或者数字间的连接

7. 位运算符：效率高，速度快:

   位移运算符：>>(右移),<<(左移)

   1. 右移操作  	==> 有符号数	正数补0；负数补1

      ​					 ==> 无符号数    正数补0；负数补0

   2. 左移操作  << 后面补0（不管正负数）移动一位除2
      
   3.  &，|，^  ==> 位 与，或，异或（相同为0，不同为1）运算；两数转化为二进制数，再逐位运算



### 1.4、Java分支结构

#### 1.4.1、if条件语句

```java
import java.util.Scanner;

Scanner s = new Scanner(System.in);//写一遍即可完成多个输入
int a = s.nextInt();
int b = s.nextInt();

//判断是否为闰年
if(year%4==0 && year%100!=0 || year%400==0)
```



#### 1.4.2、switch-case结构：

 		switch(表达式值)；()中只能放byte、short、char、int类型（小于int类型）和枚举类型

   ```java
   //语法结构：
   switch(xxx) {
       case 值1:
           语句1;
       case 值2:
           语句2;
       case 值3:
           语句3;
           ………………
       default:
           语句0;
   }
   ```



### 1.5、循环结构

#### 1.5.1、for循环

```java
for(表达式1;表达式2(条件);表达式3) {
	循环体;
}
//continue：结束本次循环，执行下一次循环（执行第三个表达式）
//break：   结束循环，直接跳出for结构，执行后面的语句
```

> for循环的特殊结构：

   (1). for(); 没有循环体；

   (2). for(;;){}省略表达式;均可省略，但需要在其他地方补充；

​	(3). for嵌套循环中的break；跳出其所在的那个for循环，不跳出整个嵌套循环。

```java
//例子：求1--100的和的三种写法
int j = 1;
int sum = 0;
//省略表达式1
for(; j <= 100; j++){
    sum += j;
}
//省略表达式1,2
for( ; ; j++){ 
    if(j > 100) 
        break; 
    sum += j;
}
//省略表达式3
for(; j <= 100; ){ 
    sum += j; 
    j++;
}
```



#### 1.5.2、while循环



#### 1.5.3、do while循环





### 1.6、函数

#### 1.6.1、函数的声明：

​		函数名书写习惯：首字母小写，望文生义；多单词组成驼峰式命名

```java
public static 返回值类型  函数名(形式参数列表)
{
	//函数体;
}
```



#### 1.6.2、函数返回值类型：

- 函数是一个过程的调用，能够得到一些结果；

- 若结果是具体值(可以用变量进行接收，只能通过return关键字返回);

- 返回值类型就是该数值的类型；若没有返回值，那么返回值为void.

  

#### 1.6.3、函数的位置和作用域：

> 位置和主函数并列，作用域如下表

| 作用域             | 当前类 | 同package | 子孙类 | 其它package |
| ------------------ | ------ | --------- | ------ | ----------- |
| public             | √      | √         | √      | √           |
| protected          | √      | √         | √      | ×           |
| friendly（默认值） | √      | √         | ×      | ×           |
| private            | √      | ×         | ×      | ×           |



#### 1.6.4、函数返回：

1. 函数运行结束;

2. 函数遇到return语句；

3. 抛出异常；

   ps:函数有返回值类型，没有return语句，无法通过编译;
   
   

#### 1.6.5、内存堆、栈；

> 栈内存：

栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。

> 堆内存：

存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。



堆与栈的区别：

1. 栈内存存储的是局部变量，而堆内存存储的是实体；
2. 栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；
3. 栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。



### 1.7、数组

#### 1.7.1、数组的声明

​		数组定义：相同数据类型元素的集合；声明方法如下三种：

```Java
//1、[]写在右间也行a[]，但一般写在中间[] a;
int[] a = {10,9,8...};  

//2、数组下标从0开始
int[] b; b = new int[]{1,2,3...}; 
//等价于====>
int b = new int[]{1,2,3...};

//3、先定义，然后分别初始化
int[] c = new int[10];  
```



#### 1.7.2、数组的访问

​		数组名.length 得到数组长度，通过下标访问，下标从0开始。
 		访问方法：数组名[下标]。

PS:数组名，是对数组的引用(数组名指向了那个数组===>就是数组的地址)



#### 1.7.3、数组的引用类型

​		数组是引用类型，数组开辟的是堆内存，将来释放时，需要JVM回收。

```java
/*b指向a数组的地址；所以对改变数组b的值就是在改变a数组的值
  数组作为函数的形式参数: 函数名(int[] b){}
  数组作为函数返回值类型：int[] 函数名(int[] b){}
  **一般来说，返回数组值，不需要写返回值void fname(int[] a){}
  */
int[] a = {1,2,3,4}
int[] b = a;
for(int i=0;i<b.length;i++) {
    b[i]++;
}
for(int i=0;i<a.length;i++) {
    System.out.println(a[i]+" ");
}
```



#### 1.7.4、数组的扩容、复制

java.lang.ArrayIndexOutOfBoundsException  数组下标越界异常



#### 1.7.5、数组的排序

1. 选择排序;

2. 冒泡排序;

3. 插入排序；

4. Arrays.sort()方法；

   性能对比：4>>3>2>1;



#### 1.7.6、多维数组

​		二维数组，由多个一维数组组成，每个一维数组都是二维数组的一个元素，二维数组的长度就是其中包含的一维数组的个数。

> 声明方法如下：



```java
int[][] a = {{},{}……,{}};
int[][] a = new int[][]{{},{}……,{}};
int[][] a = new int[][];
int[][] a = { {1,2,3},{4,5,6} }	//===》a.length=2

	/*
	若a中有三个一维数组
	则，第一个数组名为a[0]
	    第二个数组名为a[1];第三个数组名为a[2]
	*/	
	//访问第二个一维数组的所有元素
	for(i=0;i<a[0].length;i++)
	{
		System.out.println(a[0][i]);
	}
	//遍历所有元素
	for(i=0;i<a.length;i++)
	{
	    for(j=0;j<a[i].length;j++)
	    {
	        System.out.println(a[i][j]);
	    }
	}
```



> 三维数组：

​		有多个二维数组组成，每个二维数组都是三维数组的一个元素，三维数组的长度就是包含在其中的二维数组的个数。

> 三维数组声明方式：

​		依照一维数组、二维数组推理；原理相同；
​		a[1]==>表示三维数组的第二个二维数组。



#### 1.7.7、字符串数组

​		字符串：由多个字符组成；一个字符2个字节；

​		字符串数组String[] name = {"one","two","three","four"};

```Java
//字符串遍历
for(int i=0;i<name.length;i++) {
    System.out.println(name[i]);
}

String[][] teamnames[][] = {{"one","two"},{"three","four"}}
for(int i=0;i<String.length;i++) {
    for(int j=0;j<String[i].length;j++){
        System.out.println(teamname[i][j]+" ");
    }
    System.out.println();
}

//控制台输入字符串
Scanner s = new Scanner(System.in);
String str1 = s.next();//s.nextLine();
//把一个字符串数组转换成数字类型
String str2 = "123";
int c = Integer.parseInt(str2);
System.out.println(c);
```



#### 1.7.8、局部变量必须初始化，否则不能使用

```java
String[] name = null;
int[] a = null;
//null也是一种初始化方式；写null指次数组没有指向任何内存空间
System.out.println(a);====>输出null;
System.out.println(name);====>输出null;
```



### 第一阶段案例：

1. 创建一个数组，通过键盘输入进行初始化，求数组中的最大值、最小值、和、平均值；

2. 创建一个数组并初始化，然后让这个数组倒置；

3. 将数组倒置写成函数;

4. 获取两个正int类型数组中相同且最大的元素;

5. 数组已经初始化完毕，像数组下标3插入一个新元素100;

6. 几个常用函数：

   - a. Java提供数组复制函数System.arraycopy(a,0,b,0,a.length);

     参数1：源数组
     参数2：源数组那个位置开始copy
     参数3：目标数组
     参数4：copy到目标数组的起始位置
     参数5: copy目标数组中几个元素

   -  Java提供的数组输出函数：

     ```java
     System.out.println(Arrays.toString());
     ```

   - Java复制并扩容数组的函数

     ```java
     import java.util.Arrays;
     
     a = Arrays.copyOf(a,2*a.length);//扩容函数
     ```

7. 写一个函数，向整个数组的任意位置插入一个数;

8. 排序问题

   ```java
   /*
   1、选择排序：
       思路：a[0] a[1] a[2] a[3]
       1. a[0]和后面元素比较，若a[0]大，则交换===》最小的放入a[0]中
       2. a[1]和后面元素比较，……
       3. 循环a.length-1轮
   2、冒泡排序：
       思路：a[0] a[1] a[2] a[3]
       1. a[0]和a[1],a[1]和a[2],a[2]和a[3],前大，则交换===》最大排入最后
       a[0]和a[1],a[1]和a[2]
       2. 共a.length-1轮循环
       选择排序、冒泡排序性能低，排序慢；插入排序较前两种较快；
       最快的是Arrays.sort()方法。
       
   3、插入排序:
   	引入：写一个函数，向一个已经排好序的数组，插入一个元素，插入后数组还是排好序的。
   	插入排序：即多次使用引入案例；
   4、数组中本身提供的排序API
   	Array.sort(a);
   */
   
   //1、选择排序：
   public static void choiceSort(int[] a)
   {
       for (int i=0;i<a.length-1;i++ )
       {
           for (int j=i+1;j<a.length;j++ )
           {
               if (a[i]>a[j])
               {
                   int t = a[i];
                   a[i] = a[j];
                   a[j] = t;
               }
           }
       }
   }
   
   //2、冒泡排序：
   public static void maopaoSort(int[] a) 
   {
       for (int i=0;i<a.length-1 ;i++ )
       {
           for (int j=0;j<a.length-1-i ;j++ )
           {
               if (a[j]>a[j+1])
               {
                   int t = a[j];
                   a[j] = a[j+1];
                   a[j+1] = t;
               }
           }
       }
   
   }
   
   //3、插入排序：
   public static int[] insertSort(int[] a)
   {
       //
       int t=0,j;
       //插入
       for (int i=1;i<a.length;i++ )//插入的次数
       {
           /*
   			for (j=i-1;j>=0 ;j-- )//一次插入的过程
   			{
   				t = a[i];
   
   				if (t<a[j])
   				{
   					a[j+1] = a[j];
   				}
   				else
   					break;
   
   
   			}*/
           //上述注释部分等价于下面这段代码：
           t = a[i];
           for (j=i-1;j>=0 && t<a[j] ;j-- )
           {
               a[j+1] = a[j];
           }
           a[j+1] = t;
       }
       return a;
   }
   
   
   //4、Java API 排序：
   public static void Sort(int[] a) {
       //数组初始化后，再调用
       Array.sort(a); 
   }
   
   //随机数生成方法：
   import java.util.Random;
   Random r = new Random();
   a[i] = r.nextInt();     
   ```

   

9. 杨辉三角

   ```
   1
   1 1
   1 2 1    		====> a[3][1] = a[2][0] + a[2][1]
   1 3 3 1         ====> a[i][j] = a[i-1][j-1] + a[i-1][j]
   1 4 6 4 1
   …………
   ```

   ​	 

10. 双色球6个红球(33选1) 一颗蓝球(16选1)

    01，02，03，....(用字符串数组表示数字)

    

#### 第一阶段大案例：

> 酒店前台客房管理系统，系统描述如下：

```
1. 酒店12层，每层10个房间，要求为该酒店设计一套简单的前台房间管理系统；
2. 该程序可以通过在命令行输入命令来为客人办理入住和退房手续
3. 要求该程序支持通过命令行输入以下命令来进行入住，退房及查询操作
	(1). search():查询所有房间的状态；初始为empty
    (2). in(房间号码，姓名)：客人入住
    	命令：
        请输入客人入住的房间号
        1201
    	请输入入住1201房间的客人的姓名
    	parker
    (3). out(房间号码)：客人退房
        命令：out 1201
        提示：1201房间退房
        注意：如果某个房间已经有客人入住，在办理入住时，
        将提示“该房间已经有人入住，请重新选择！”
    (4). quit：退出程序
```















